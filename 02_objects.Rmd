---
title: "2 Объекты"
output: html_document
---

```{r, echo = FALSE}
setwd("D:/GITHUB/rlang_manual_ru/")
```

В каждом компьютерном языке переменные обеспечивают средства доступа к данным, хранящимся в памяти. R не обеспечивает непосредственного доступа к памяти компьютера, а скорее предоставляет ряд
специализированных структур данных, к которым мы будем обращаться как к объектам. Обращение к этим объектам происходит посредством символов (symbol) или переменных (variable). Тем не менее, в R символы сами по себе являются объектами, и с ними можно совершать те же действия, что и с другими объектами. Это отличает R от многих других языков и приводит к далеко идущим последствиям.
В этой главе мы приводим предварительные описания различных структур данных, представленных в R. Более подробное обсуждение многих из них можно найти в последующих главах. Специальная функция **typeof** возвращает *тип* объекта R. Обратите внимание, что в коде на C, лежащем в основе R, все объекты являются указателями на структуру с типом (typedef) **SEXPREC**; разные типы данных R представлены в C с помощью **SEXPTYPE**, определяющего, как используется информация из разных частей структуры.

Следующая таблица описывает возможные значения, возвращаемые функцией **typeof**, и что они из себя представляют.

| Тип           |                                                           |
|---------------|:----------------------------------------------------------|
| "NULL"        | NULL                                                      |
| "symbol"      | имя переменной                                            |
| "pairlist"    | объект типа "список пар" (преимущественно внутренний)     |
| "closure"     | функция                                                   |
| "environment" | окружение                                                 |
| "promise"     | объект, используемый для реализации "ленивых" вычислений  |
| "language"    | конструкция языка R                                       |
| "special"     | внутренняя функция, которая не вычисляет свои аргументы   |
| "builtin"     | внутренняя функция, которая вычисляет свои аргументы      |
| "char"        | "скалярный" объект-строка (исключительно внутренний)\*\*\*|
| "logical"     | вектор, содержащий логические значения                    |
| "integer"     | вектор, содержащий целочисленные значения                 |
| "double"      | вектор, содержащий вещественночисленные значения          |
| "complex"     | вектор, содержащий комплексные значения                   |
| "character"   | вектор, содержащий символьные значения                    |
| "..."         | специальный аргумент вариабельной длины\*\*\*             |
| "any"         | специальный тип, которому соответствуют все типы: объектов этого типа не существует |
| "expression"  | объект-выражение                                          |
| "list"        | список                                                    |
| "bytecode"    | байт-код (исключительно внутренний)\*\*\*                 |
| "externalptr" | внешний объект-указатель                                  |
| "weakref"     | объект, представляющий собой слабую ссылку                |
| "raw"         | вектор, содержащий байты                                  |
| "S4"          | объект S4, не являющийся простым объектом                 |

Пользователи не могут просто получить доступ к объектам, отмеченным "\*\*\*".

Функция **mode** дает информацию о *режиме* объекта в смысле, подразумеваемом Becker-ом, Chambers-ом & Wilks-ом (1988). Она также более совместима с другими реализациями языка S.
Наконец, функция **storage.mode** возвращает *режим хранения* её аргументов в смысле, подразумеваемом Becker-ом и др. (1988). Она обычно используется при вызове функций, написанных на другом языке, таком как C или FORTRAN, чтобы убедиться, что объект R имеет тип данных, который ожидается вызываемой подпрограммой. (В языке S векторы с целочисленными или вещественными значениями имеют режим "numeric", поэтому необходимо, чтобы их режимы хранения были разлиными.)

```{r, eval=FALSE}
> x <- 1:3
> typeof(x)
[1] "integer"
> mode(x)
[1] "numeric"
> storage.mode(x)
[1] "integer"
```

Объекты R часто приводятся к разным типам в процессе вычислений. Также доступно много функций для выполнения приведения в явном виде. При программировании на языке R тип объекта обычно не влияет на вычисления, однако при работе с другими языками или с операционной системой часто бывает необходимо гарантировать, что объект имеет правильный тип.


## 2.1 Основные типы

### 2.1.1 Векторы

Векторы можно рассматривать как смежные ячейки, содержащие данные. Доступ к ячейкам осуществляется при помощи операций индексирования, таких как **x[5]**. Подробности приведены в Разделе 3.4 [Индексирование].

R имеет шесть базовых ("атомарных") типов векторов: логические (logical), целочисленные (integer), вещественночисленные (real), комплексные (complex), строковые/символьные (string/character)) и "сырые" (raw). Режимы и режимы хранения векторов разных типов перечислены в следующей таблице.

| Тип           | Режим                         | Режим хранения            |
|---------------|:------------------------------|:--------------------------|
| logical       | logical                       | logical                   |
| integer       | numeric                       | integer                   |
| double        | numeric                       | double                    |
| complex       | complex                       | complex                   |
| character     | character                     | character                 |
| raw           | raw                           | raw                       |

Отдельные числа, такие как **4.2**, и строки, такие как **"four point two"**, все равно являются являются векторами, длина которых равна 1; других базовых типов не существует. Векторы нулевой длины возможны (и полезны).

Режимом и режимом хранения строковых векторов является режим **"character"**. Отдельный элемент символьного вектора часто называют *символьной строкой*.


### 2.1.2 Списки

Списки ("обобщенные векторы") являются другим типом хранилища данных. Списки содержат элементы, каждый из которых может содержать объекты R любого типа, т.е. элементы списка не обязаны иметь один и тот же тип. Доступ к элементам списка осуществляется с помощью трех разных операций индексирования. Подробности приведены в Разделе 3.4 [Индексирование].

Списки являются векторами, и векторы базовых типов называют *атомарными векторами* из-за необходимости исключить из их числа списки.


### 2.1.3 Объекты языка

Существует три типа объектов, из которых состоит язык R. Это *вызовы* (calls), *выражения* (expressions) и *имена* (names). Поскольку R имеет объекты типа **"expressions"**, мы будем избегать использования слова "выражение"" в других контекстах. В частности, синтаксически корректные выражения будут называться *инструкциями* (statements).

Эти объекты имеют режимы **"call"**, **"expression"** и **"name"** соответственно.

Они могут быть созданы непосредственно из выражений с использованием механизма **quote** и преобразованы в списки и из списков при помощи функций **as.list** и **as.call**. Элементы дерева парсинга (parse tree) могут быть извлечены с использованием стандартных операций индексирования.

#### 2.1.3.1 Объекты-символы

Символы ссылаються на объекты R. Имя любого объекта R обычно является символом. Сиволы могут создаваться функциями **as.name** и **quote**.

Символы имеют режим **"name"**, режим хранения **"symbol"** и тип **"symbol"**. Они могут быт преведены в форму символьных строк и получены из символьных строк при помощи **as.character** и **as.name**. Они естественным образом появляются как элементарные единицы при парсинге выражений, например, см. **as.list(quote(x + y))**.


### 2.1.4 Объекты-выражения

В R вы можете иметь объекты типа **"expression"**. *Выражение* содержит одну или более инструкций. Инструкция является синтаксически корректным набором лексем (tokens). Объекты-выражения являются специальными объектами языка, содержащими проанализированные, но невычисленные инструкции. Основное различие заключается в том, что объект-выражение может содержать несколько таких выражений. Еще одним более тонким различием является то, что объекты типа **"expression"** вычисляются только при явной передаче функции **eval**, в то время как другие объекты языка могут вычисляться в некоторых непредвиденных случаях.

Объекты-выражения ведут себя подобно спискам, и доступ к их элементам должен осуществляться так же, как к элементам списка.


### 2.1.5 Объекты-функции




